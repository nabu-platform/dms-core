package be.nabu.libs.dms.converters;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Proxy;
import java.net.URL;
import java.net.Proxy.Type;
import java.net.URLConnection;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import be.nabu.libs.dms.FileUtils;
import be.nabu.libs.dms.api.Converter;
import be.nabu.libs.dms.api.DocumentManager;
import be.nabu.libs.dms.api.FormatException;
import be.nabu.libs.vfs.api.File;
import be.nabu.utils.codec.TranscoderUtils;
import be.nabu.utils.codec.impl.Base64Decoder;
import be.nabu.utils.io.ContentTypeMap;
import be.nabu.utils.io.IOUtils;

public class EHTMLToDXF implements Converter {

	@Override
	public void convert(DocumentManager documentManager, File file, OutputStream output, Map<String, String> properties) throws IOException, FormatException {
		// for some reason the browser generates "&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;" for a tab
		String html = FileUtils.toString(file, "UTF-8").replaceAll("&nbsp; &nbsp;", "&nbsp;&nbsp;&nbsp;");
		html = html.replaceAll(TAB_SPACES, "\t");
		// 6 spaces = 1 tab, this is generated by the browser
		html = html.replaceAll("      ", "\t");
		html = html.replaceAll("&nbsp;", " ");
		// externalize embedded images
		html = unembedImages(file, html);
		
		IOUtils.copyBytes(IOUtils.wrap(new ByteArrayInputStream(html.getBytes("UTF-8"))), IOUtils.wrap(output));
	}

	private String unembedImages(File file, String content) throws IOException {
		Pattern pattern = Pattern.compile("(<img[^>]+?src[\\s='\"]+)([^'\"]+)('|\")([^>]+)>");
		Matcher matcher = pattern.matcher(content);
		while (matcher.find()) {
			String src = matcher.group().replaceAll(pattern.pattern(), "$2");
			if (src.startsWith("data:") || src.startsWith("http:") || src.startsWith("https:")) {
				File target = file.getParent().resolve(".resources");
				if (!target.exists()) {
					target.mkdir();
				}
				String fileName = null;
				if (matcher.group().matches("(?i).*alt[\\s]*=[\\s]*.*")) {
					String alt = matcher.group().replaceAll("(?i).*alt[\\s='\"]+([^'\"]+).*", "$1");
					if (!alt.equals(matcher.group()) && !alt.isEmpty()) {
						// if it's a URI, remove everything before the last slash
						// also make sure you only use simple characters
						fileName = alt.replaceAll(".*/", "").replaceAll("[^\\w.]+", "_");
					}
				}
				String mimeType = src.startsWith("data:") 
					? src.replaceAll("^data:([^;]+).*", "$1")
					: ContentTypeMap.getInstance().getContentTypeFor(src);
				if (mimeType == null) {
					throw new IllegalArgumentException("Unsupported image format");
				}
				String extension = ContentTypeMap.getInstance().getExtensionFor(mimeType);
				if (fileName != null && !fileName.endsWith("." + extension)) {
					fileName += "." + extension;
				}
				int counter = 0;
				// make sure it's unique
				while (fileName == null || target.resolve(fileName).exists()) {
					fileName = fileName == null 
						? "unnamed" + counter++ + "." + extension
						: fileName.replaceFirst("^([^.0-9]+)[0-9]*", "$1" + counter++);
				}
				byte [] bytes;
				if (src.startsWith("data:")) {
					String encoding = src.replaceAll("^data:[^;]+;([^,]+).*", "$1").toLowerCase();
					if (!"base64".equals(encoding)) {
						throw new RuntimeException("Currently there is only support base64 encoding for embedded images, not " + encoding);
					}
					String encoded = src.replaceAll("^data:[^;]+;[^,]+,(.*)$", "$1");
					bytes = IOUtils.toBytes(TranscoderUtils.transcodeBytes(IOUtils.wrap(encoded.getBytes(), true), new Base64Decoder()));
				}
				// currently a best effort copy
				else {
					URL url = new URL(src);
					URLConnection connection;
					if (System.getProperty("http.proxyHost") != null) {
						connection = url.openConnection(new Proxy(Type.HTTP, new InetSocketAddress(System.getProperty("http.proxyHost"), Integer.parseInt(System.getProperty("http.proxyPort", "8080")))));
					}
					else {
						connection = url.openConnection();
					}
					InputStream inputStream = connection.getInputStream(); 
					try {
						bytes = IOUtils.toBytes(IOUtils.wrap(inputStream));
					}
					finally {
						inputStream.close();
					}
				}
				OutputStream output = target.resolve(fileName).getOutputStream();
				try {
					output.write(bytes);
				}
				finally {
					output.close();
				}
				content = content.replaceAll(Pattern.quote(matcher.group()), "<link href=\".resources/" + fileName + "\" reference=\".resources/" + fileName + "\"/>");
			}
		}
		return content;
	}

	@Override
	public List<String> getContentTypes() {
		return Arrays.asList(new String [] { WikiToEHTML.EDITABLE_HTML });
	}

	@Override
	public String getOutputContentType() {
		return DOCUMENT_EXCHANGE_FORMAT_CONTENT_TYPE;
	}

	@Override
	public boolean isLossless() {
		return true;
	}

}
